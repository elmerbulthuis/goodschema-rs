pub static SCHEMA_ID: &str = "https://schema.JsonSchema42.org/jns42-intermediate-a/schema.json";

// @generated by
//     __             _____     _                 ___ ___
//  _ |  |___ ___ ___|   __|___| |_ ___ _____  __| | |_  |
// | |_| |_ -| . |   |__   |  _|   | -_|     ||. |_  |  _|
// |_____|___|___|_|_|_____|___|_|_|___|_|_|_|___| |_|___|
//                                 -- www.JsonSchema42.org

#[derive(Debug)]
pub struct ValidationError {
    r#type: &'static str,
}
impl ValidationError {
    pub fn new(r#type: &'static str) -> Self {
        Self { r#type }
    }
}
impl std::fmt::Display for ValidationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "validation error for type {}", self.r#type)
    }
}
pub type r#MaximumLength = r#MaximumLengthNumber;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, Copy, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "usize")]
pub struct r#MaximumLengthNumber(usize);
impl r#MaximumLengthNumber {
    fn new(value: usize) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("MaximumLengthNumber"))
        }
    }
    pub fn validate(&self) -> bool {
        if self.0 == 0 {
            return false;
        }
        true
    }
}
impl TryFrom<usize> for r#MaximumLengthNumber {
    type Error = ValidationError;
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#MaximumLengthNumber> for usize {
    fn from(value: r#MaximumLengthNumber) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#MaximumLengthNumber {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let value = s
            .parse()
            .map_err(|_error| ValidationError::new("MaximumLengthNumber"))?;
        Self::new(value)
    }
}
impl ToString for r#MaximumLengthNumber {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<usize> for r#MaximumLengthNumber {
    fn as_ref(&self) -> &usize {
        &self.0
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#MaximumLengthNumber {
    type Target = usize;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type r#DefsNumberType = r#DefsNumberTypeInterface;
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
pub struct r#DefsNumberTypeInterface {
    #[serde(rename = "minimumInclusive")]
    pub r#minimum_inclusive: Option<r#MinimumInclusive>,
    #[serde(rename = "multipleOf")]
    pub r#multiple_of: Option<r#MultipleOf>,
    #[serde(rename = "type")]
    pub r#type: r#NumberTypeType,
    #[serde(rename = "numberType")]
    pub r#number_type: Option<r#PropertiesNumberType>,
    #[serde(rename = "minimumExclusive")]
    pub r#minimum_exclusive: Option<r#MinimumExclusive>,
    #[serde(rename = "options")]
    pub r#options: Option<r#NumberTypeOptions>,
    #[serde(rename = "maximumInclusive")]
    pub r#maximum_inclusive: Option<r#MaximumInclusive>,
    #[serde(rename = "maximumExclusive")]
    pub r#maximum_exclusive: Option<r#MaximumExclusive>,
}
pub type r#ExamplesItems = r#ExamplesItemsAny;
pub type r#ExamplesItemsAny = serde_json::Value;
pub type r#ValuePattern = r#ValuePatternString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#ValuePatternString(String);
impl r#ValuePatternString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("ValuePatternString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#ValuePatternString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#ValuePatternString> for String {
    fn from(value: r#ValuePatternString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#ValuePatternString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#ValuePatternString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#ValuePatternString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#ValuePatternString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#OneOfCompoundTypeNodeIdsItems = r#OneOfCompoundTypeNodeIdsItemsString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#OneOfCompoundTypeNodeIdsItemsString(String);
impl r#OneOfCompoundTypeNodeIdsItemsString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("OneOfCompoundTypeNodeIdsItemsString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#OneOfCompoundTypeNodeIdsItemsString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#OneOfCompoundTypeNodeIdsItemsString> for String {
    fn from(value: r#OneOfCompoundTypeNodeIdsItemsString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#OneOfCompoundTypeNodeIdsItemsString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#OneOfCompoundTypeNodeIdsItemsString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#OneOfCompoundTypeNodeIdsItemsString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#OneOfCompoundTypeNodeIdsItemsString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#MaximumProperties = r#MaximumPropertiesNumber;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, Copy, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "usize")]
pub struct r#MaximumPropertiesNumber(usize);
impl r#MaximumPropertiesNumber {
    fn new(value: usize) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("MaximumPropertiesNumber"))
        }
    }
    pub fn validate(&self) -> bool {
        if self.0 == 0 {
            return false;
        }
        true
    }
}
impl TryFrom<usize> for r#MaximumPropertiesNumber {
    type Error = ValidationError;
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#MaximumPropertiesNumber> for usize {
    fn from(value: r#MaximumPropertiesNumber) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#MaximumPropertiesNumber {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let value = s
            .parse()
            .map_err(|_error| ValidationError::new("MaximumPropertiesNumber"))?;
        Self::new(value)
    }
}
impl ToString for r#MaximumPropertiesNumber {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<usize> for r#MaximumPropertiesNumber {
    fn as_ref(&self) -> &usize {
        &self.0
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#MaximumPropertiesNumber {
    type Target = usize;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type r#UniqueItems = r#UniqueItemsBoolean;
#[derive(
    Debug,
    serde :: Serialize,
    serde :: Deserialize,
    Clone,
    Copy,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
)]
#[serde(try_from = "bool")]
pub struct r#UniqueItemsBoolean(bool);
impl r#UniqueItemsBoolean {
    fn new(value: bool) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("UniqueItemsBoolean"))
        }
    }
    pub fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<bool> for r#UniqueItemsBoolean {
    type Error = ValidationError;
    fn try_from(value: bool) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#UniqueItemsBoolean> for bool {
    fn from(value: r#UniqueItemsBoolean) -> Self {
        value.0
    }
}
impl AsRef<bool> for r#UniqueItemsBoolean {
    fn as_ref(&self) -> &bool {
        &self.0
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#UniqueItemsBoolean {
    type Target = bool;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type r#MinimumInclusive = r#MinimumInclusiveNumber;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, Copy, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "usize")]
pub struct r#MinimumInclusiveNumber(usize);
impl r#MinimumInclusiveNumber {
    fn new(value: usize) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("MinimumInclusiveNumber"))
        }
    }
    pub fn validate(&self) -> bool {
        if self.0 == 0 {
            return false;
        }
        true
    }
}
impl TryFrom<usize> for r#MinimumInclusiveNumber {
    type Error = ValidationError;
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#MinimumInclusiveNumber> for usize {
    fn from(value: r#MinimumInclusiveNumber) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#MinimumInclusiveNumber {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let value = s
            .parse()
            .map_err(|_error| ValidationError::new("MinimumInclusiveNumber"))?;
        Self::new(value)
    }
}
impl ToString for r#MinimumInclusiveNumber {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<usize> for r#MinimumInclusiveNumber {
    fn as_ref(&self) -> &usize {
        &self.0
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#MinimumInclusiveNumber {
    type Target = usize;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type r#OneOfCompound = r#OneOfCompoundInterface;
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
pub struct r#OneOfCompoundInterface {
    #[serde(rename = "type")]
    pub r#type: r#OneOfCompoundType,
    #[serde(rename = "typeNodeIds")]
    pub r#type_node_ids: Option<r#OneOfCompoundTypeNodeIds>,
}
pub type r#RecordType = r#RecordTypeInterface;
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
pub struct r#RecordTypeInterface {
    #[serde(rename = "propertyTypeNodeId")]
    pub r#property_type_node_id: Option<r#PropertyTypeNodeId>,
    #[serde(rename = "maximumProperties")]
    pub r#maximum_properties: Option<r#MaximumProperties>,
    #[serde(rename = "requiredProperties")]
    pub r#required_properties: Option<r#RecordTypeRequiredProperties>,
    #[serde(rename = "type")]
    pub r#type: r#RecordTypeType,
    #[serde(rename = "minimumProperties")]
    pub r#minimum_properties: Option<r#MinimumProperties>,
}
pub type r#Title = r#TitleString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#TitleString(String);
impl r#TitleString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("TitleString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#TitleString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#TitleString> for String {
    fn from(value: r#TitleString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#TitleString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#TitleString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#TitleString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#TitleString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#MaximumExclusive = r#MaximumExclusiveNumber;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, Copy, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "usize")]
pub struct r#MaximumExclusiveNumber(usize);
impl r#MaximumExclusiveNumber {
    fn new(value: usize) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("MaximumExclusiveNumber"))
        }
    }
    pub fn validate(&self) -> bool {
        if self.0 == 0 {
            return false;
        }
        true
    }
}
impl TryFrom<usize> for r#MaximumExclusiveNumber {
    type Error = ValidationError;
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#MaximumExclusiveNumber> for usize {
    fn from(value: r#MaximumExclusiveNumber) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#MaximumExclusiveNumber {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let value = s
            .parse()
            .map_err(|_error| ValidationError::new("MaximumExclusiveNumber"))?;
        Self::new(value)
    }
}
impl ToString for r#MaximumExclusiveNumber {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<usize> for r#MaximumExclusiveNumber {
    fn as_ref(&self) -> &usize {
        &self.0
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#MaximumExclusiveNumber {
    type Target = usize;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type r#BooleanTypeOptionsItems = r#BooleanTypeOptionsItemsBoolean;
#[derive(
    Debug,
    serde :: Serialize,
    serde :: Deserialize,
    Clone,
    Copy,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
)]
#[serde(try_from = "bool")]
pub struct r#BooleanTypeOptionsItemsBoolean(bool);
impl r#BooleanTypeOptionsItemsBoolean {
    fn new(value: bool) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("BooleanTypeOptionsItemsBoolean"))
        }
    }
    pub fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<bool> for r#BooleanTypeOptionsItemsBoolean {
    type Error = ValidationError;
    fn try_from(value: bool) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#BooleanTypeOptionsItemsBoolean> for bool {
    fn from(value: r#BooleanTypeOptionsItemsBoolean) -> Self {
        value.0
    }
}
impl AsRef<bool> for r#BooleanTypeOptionsItemsBoolean {
    fn as_ref(&self) -> &bool {
        &self.0
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#BooleanTypeOptionsItemsBoolean {
    type Target = bool;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type r#MinimumExclusive = r#MinimumExclusiveNumber;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, Copy, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "usize")]
pub struct r#MinimumExclusiveNumber(usize);
impl r#MinimumExclusiveNumber {
    fn new(value: usize) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("MinimumExclusiveNumber"))
        }
    }
    pub fn validate(&self) -> bool {
        if self.0 == 0 {
            return false;
        }
        true
    }
}
impl TryFrom<usize> for r#MinimumExclusiveNumber {
    type Error = ValidationError;
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#MinimumExclusiveNumber> for usize {
    fn from(value: r#MinimumExclusiveNumber) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#MinimumExclusiveNumber {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let value = s
            .parse()
            .map_err(|_error| ValidationError::new("MinimumExclusiveNumber"))?;
        Self::new(value)
    }
}
impl ToString for r#MinimumExclusiveNumber {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<usize> for r#MinimumExclusiveNumber {
    fn as_ref(&self) -> &usize {
        &self.0
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#MinimumExclusiveNumber {
    type Target = usize;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type r#StringTypeType = r#StringTypeTypeString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#StringTypeTypeString(String);
impl r#StringTypeTypeString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("StringTypeTypeString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#StringTypeTypeString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#StringTypeTypeString> for String {
    fn from(value: r#StringTypeTypeString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#StringTypeTypeString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#StringTypeTypeString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#StringTypeTypeString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#StringTypeTypeString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#AnyTypeType = r#AnyTypeTypeString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#AnyTypeTypeString(String);
impl r#AnyTypeTypeString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("AnyTypeTypeString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#AnyTypeTypeString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#AnyTypeTypeString> for String {
    fn from(value: r#AnyTypeTypeString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#AnyTypeTypeString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#AnyTypeTypeString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#AnyTypeTypeString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#AnyTypeTypeString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#MinimumItems = r#MinimumItemsNumber;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, Copy, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "usize")]
pub struct r#MinimumItemsNumber(usize);
impl r#MinimumItemsNumber {
    fn new(value: usize) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("MinimumItemsNumber"))
        }
    }
    pub fn validate(&self) -> bool {
        if self.0 == 0 {
            return false;
        }
        true
    }
}
impl TryFrom<usize> for r#MinimumItemsNumber {
    type Error = ValidationError;
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#MinimumItemsNumber> for usize {
    fn from(value: r#MinimumItemsNumber) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#MinimumItemsNumber {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let value = s
            .parse()
            .map_err(|_error| ValidationError::new("MinimumItemsNumber"))?;
        Self::new(value)
    }
}
impl ToString for r#MinimumItemsNumber {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<usize> for r#MinimumItemsNumber {
    fn as_ref(&self) -> &usize {
        &self.0
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#MinimumItemsNumber {
    type Target = usize;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type r#CompoundUnionOneOf2 = r#AllOfCompound;
pub type r#ArrayType = r#ArrayTypeInterface;
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
pub struct r#ArrayTypeInterface {
    #[serde(rename = "minimumItems")]
    pub r#minimum_items: Option<r#MinimumItems>,
    #[serde(rename = "type")]
    pub r#type: r#ArrayTypeType,
    #[serde(rename = "maximumItems")]
    pub r#maximum_items: Option<r#MaximumItems>,
    #[serde(rename = "itemTypeNodeId")]
    pub r#item_type_node_id: Option<r#ItemTypeNodeId>,
    #[serde(rename = "uniqueItems")]
    pub r#unique_items: Option<r#UniqueItems>,
}
pub type r#OneOfCompoundTypeNodeIds = r#OneOfCompoundTypeNodeIdsArray;
pub type r#OneOfCompoundTypeNodeIdsArray = Vec<r#OneOfCompoundTypeNodeIdsItems>;
pub type r#SuperNodeId = r#SuperNodeIdString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#SuperNodeIdString(String);
impl r#SuperNodeIdString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("SuperNodeIdString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#SuperNodeIdString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#SuperNodeIdString> for String {
    fn from(value: r#SuperNodeIdString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#SuperNodeIdString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#SuperNodeIdString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#SuperNodeIdString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#SuperNodeIdString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#TupleType = r#TupleTypeInterface;
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
pub struct r#TupleTypeInterface {
    #[serde(rename = "type")]
    pub r#type: r#TupleTypeType,
    #[serde(rename = "itemTypeNodeIds")]
    pub r#item_type_node_ids: Option<r#ItemTypeNodeIds>,
}
pub type r#PropertyTypeNodeIds = r#PropertyTypeNodeIdsRecord;
pub type r#PropertyTypeNodeIdsRecord =
    std::collections::HashMap<String, r#PropertyTypeNodeIdsAdditionalProperties>;
pub type r#MaximumItems = r#MaximumItemsNumber;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, Copy, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "usize")]
pub struct r#MaximumItemsNumber(usize);
impl r#MaximumItemsNumber {
    fn new(value: usize) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("MaximumItemsNumber"))
        }
    }
    pub fn validate(&self) -> bool {
        if self.0 == 0 {
            return false;
        }
        true
    }
}
impl TryFrom<usize> for r#MaximumItemsNumber {
    type Error = ValidationError;
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#MaximumItemsNumber> for usize {
    fn from(value: r#MaximumItemsNumber) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#MaximumItemsNumber {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let value = s
            .parse()
            .map_err(|_error| ValidationError::new("MaximumItemsNumber"))?;
        Self::new(value)
    }
}
impl ToString for r#MaximumItemsNumber {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<usize> for r#MaximumItemsNumber {
    fn as_ref(&self) -> &usize {
        &self.0
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#MaximumItemsNumber {
    type Target = usize;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type r#RecordTypeType = r#RecordTypeTypeString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#RecordTypeTypeString(String);
impl r#RecordTypeTypeString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("RecordTypeTypeString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#RecordTypeTypeString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#RecordTypeTypeString> for String {
    fn from(value: r#RecordTypeTypeString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#RecordTypeTypeString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#RecordTypeTypeString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#RecordTypeTypeString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#RecordTypeTypeString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#Deprecated = r#DeprecatedBoolean;
#[derive(
    Debug,
    serde :: Serialize,
    serde :: Deserialize,
    Clone,
    Copy,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
)]
#[serde(try_from = "bool")]
pub struct r#DeprecatedBoolean(bool);
impl r#DeprecatedBoolean {
    fn new(value: bool) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("DeprecatedBoolean"))
        }
    }
    pub fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<bool> for r#DeprecatedBoolean {
    type Error = ValidationError;
    fn try_from(value: bool) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#DeprecatedBoolean> for bool {
    fn from(value: r#DeprecatedBoolean) -> Self {
        value.0
    }
}
impl AsRef<bool> for r#DeprecatedBoolean {
    fn as_ref(&self) -> &bool {
        &self.0
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#DeprecatedBoolean {
    type Target = bool;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type r#AnyOfCompoundTypeNodeIds = r#AnyOfCompoundTypeNodeIdsArray;
pub type r#AnyOfCompoundTypeNodeIdsArray = Vec<r#AnyOfCompoundTypeNodeIdsItems>;
pub type r#OneOf4 = r#DefsNumberType;
pub type r#NeverType = r#NeverTypeInterface;
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
pub struct r#NeverTypeInterface {
    #[serde(rename = "type")]
    pub r#type: r#NeverTypeType,
}
pub type r#MaximumInclusive = r#MaximumInclusiveNumber;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, Copy, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "usize")]
pub struct r#MaximumInclusiveNumber(usize);
impl r#MaximumInclusiveNumber {
    fn new(value: usize) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("MaximumInclusiveNumber"))
        }
    }
    pub fn validate(&self) -> bool {
        if self.0 == 0 {
            return false;
        }
        true
    }
}
impl TryFrom<usize> for r#MaximumInclusiveNumber {
    type Error = ValidationError;
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#MaximumInclusiveNumber> for usize {
    fn from(value: r#MaximumInclusiveNumber) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#MaximumInclusiveNumber {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let value = s
            .parse()
            .map_err(|_error| ValidationError::new("MaximumInclusiveNumber"))?;
        Self::new(value)
    }
}
impl ToString for r#MaximumInclusiveNumber {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<usize> for r#MaximumInclusiveNumber {
    fn as_ref(&self) -> &usize {
        &self.0
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#MaximumInclusiveNumber {
    type Target = usize;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type r#NullType = r#NullTypeInterface;
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
pub struct r#NullTypeInterface {
    #[serde(rename = "type")]
    pub r#type: r#NullTypeType,
}
pub type r#ItemTypeNodeIds = r#ItemTypeNodeIdsArray;
pub type r#ItemTypeNodeIdsArray = Vec<r#ItemTypeNodeIdsItems>;
pub type r#OneOf3 = r#BooleanType;
pub type r#AnyOfCompoundType = r#AnyOfCompoundTypeString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#AnyOfCompoundTypeString(String);
impl r#AnyOfCompoundTypeString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("AnyOfCompoundTypeString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#AnyOfCompoundTypeString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#AnyOfCompoundTypeString> for String {
    fn from(value: r#AnyOfCompoundTypeString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#AnyOfCompoundTypeString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#AnyOfCompoundTypeString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#AnyOfCompoundTypeString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#AnyOfCompoundTypeString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#NullTypeType = r#NullTypeTypeString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#NullTypeTypeString(String);
impl r#NullTypeTypeString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("NullTypeTypeString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#NullTypeTypeString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#NullTypeTypeString> for String {
    fn from(value: r#NullTypeTypeString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#NullTypeTypeString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#NullTypeTypeString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#NullTypeTypeString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#NullTypeTypeString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#Types = r#TypesArray;
pub type r#TypesArray = Vec<r#TypesItems>;
pub type r#Description = r#DescriptionString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#DescriptionString(String);
impl r#DescriptionString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("DescriptionString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#DescriptionString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#DescriptionString> for String {
    fn from(value: r#DescriptionString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#DescriptionString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#DescriptionString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#DescriptionString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#DescriptionString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#NumberTypeType = r#NumberTypeTypeString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#NumberTypeTypeString(String);
impl r#NumberTypeTypeString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("NumberTypeTypeString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#NumberTypeTypeString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#NumberTypeTypeString> for String {
    fn from(value: r#NumberTypeTypeString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#NumberTypeTypeString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#NumberTypeTypeString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#NumberTypeTypeString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#NumberTypeTypeString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#Nodes = r#NodesRecord;
pub type r#NodesRecord = std::collections::HashMap<String, r#NodesAdditionalProperties>;
pub type r#AllOfCompound = r#AllOfCompoundInterface;
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
pub struct r#AllOfCompoundInterface {
    #[serde(rename = "typeNodeIds")]
    pub r#type_node_ids: Option<r#AllOfCompoundTypeNodeIds>,
    #[serde(rename = "type")]
    pub r#type: r#AllOfCompoundType,
}
pub type r#PropertiesNumberType = r#PropertiesNumberTypeString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#PropertiesNumberTypeString(String);
impl r#PropertiesNumberTypeString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("PropertiesNumberTypeString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#PropertiesNumberTypeString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#PropertiesNumberTypeString> for String {
    fn from(value: r#PropertiesNumberTypeString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#PropertiesNumberTypeString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#PropertiesNumberTypeString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#PropertiesNumberTypeString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#PropertiesNumberTypeString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#TypeUnion = r#TypeUnionOneOf;
#[derive(serde :: Serialize, serde :: Deserialize, Clone, Debug, PartialEq, Eq)]
#[serde(untagged)]
pub enum r#TypeUnionOneOf {
    r#TypeUnionOneOf0(r#TypeUnionOneOf0),
    r#TypeUnionOneOf1(r#TypeUnionOneOf1),
    r#TypeUnionOneOf2(r#TypeUnionOneOf2),
    r#OneOf3(r#OneOf3),
    r#OneOf4(r#OneOf4),
    r#OneOf5(r#OneOf5),
    r#OneOf6(r#OneOf6),
    r#OneOf7(r#OneOf7),
    r#OneOf8(r#OneOf8),
    r#OneOf9(r#OneOf9),
}
impl TryFrom<r#TypeUnionOneOf> for r#TypeUnionOneOf0 {
    type Error = ();
    fn try_from(value: r#TypeUnionOneOf) -> Result<Self, Self::Error> {
        match value {
            r#TypeUnionOneOf::r#TypeUnionOneOf0(value) => Ok(value),
            _ => Err(()),
        }
    }
}
impl TryFrom<r#TypeUnionOneOf> for r#TypeUnionOneOf1 {
    type Error = ();
    fn try_from(value: r#TypeUnionOneOf) -> Result<Self, Self::Error> {
        match value {
            r#TypeUnionOneOf::r#TypeUnionOneOf1(value) => Ok(value),
            _ => Err(()),
        }
    }
}
impl TryFrom<r#TypeUnionOneOf> for r#TypeUnionOneOf2 {
    type Error = ();
    fn try_from(value: r#TypeUnionOneOf) -> Result<Self, Self::Error> {
        match value {
            r#TypeUnionOneOf::r#TypeUnionOneOf2(value) => Ok(value),
            _ => Err(()),
        }
    }
}
impl TryFrom<r#TypeUnionOneOf> for r#OneOf3 {
    type Error = ();
    fn try_from(value: r#TypeUnionOneOf) -> Result<Self, Self::Error> {
        match value {
            r#TypeUnionOneOf::r#OneOf3(value) => Ok(value),
            _ => Err(()),
        }
    }
}
impl TryFrom<r#TypeUnionOneOf> for r#OneOf4 {
    type Error = ();
    fn try_from(value: r#TypeUnionOneOf) -> Result<Self, Self::Error> {
        match value {
            r#TypeUnionOneOf::r#OneOf4(value) => Ok(value),
            _ => Err(()),
        }
    }
}
impl TryFrom<r#TypeUnionOneOf> for r#OneOf5 {
    type Error = ();
    fn try_from(value: r#TypeUnionOneOf) -> Result<Self, Self::Error> {
        match value {
            r#TypeUnionOneOf::r#OneOf5(value) => Ok(value),
            _ => Err(()),
        }
    }
}
impl TryFrom<r#TypeUnionOneOf> for r#OneOf6 {
    type Error = ();
    fn try_from(value: r#TypeUnionOneOf) -> Result<Self, Self::Error> {
        match value {
            r#TypeUnionOneOf::r#OneOf6(value) => Ok(value),
            _ => Err(()),
        }
    }
}
impl TryFrom<r#TypeUnionOneOf> for r#OneOf7 {
    type Error = ();
    fn try_from(value: r#TypeUnionOneOf) -> Result<Self, Self::Error> {
        match value {
            r#TypeUnionOneOf::r#OneOf7(value) => Ok(value),
            _ => Err(()),
        }
    }
}
impl TryFrom<r#TypeUnionOneOf> for r#OneOf8 {
    type Error = ();
    fn try_from(value: r#TypeUnionOneOf) -> Result<Self, Self::Error> {
        match value {
            r#TypeUnionOneOf::r#OneOf8(value) => Ok(value),
            _ => Err(()),
        }
    }
}
impl TryFrom<r#TypeUnionOneOf> for r#OneOf9 {
    type Error = ();
    fn try_from(value: r#TypeUnionOneOf) -> Result<Self, Self::Error> {
        match value {
            r#TypeUnionOneOf::r#OneOf9(value) => Ok(value),
            _ => Err(()),
        }
    }
}
pub type r#AnyOfCompoundTypeNodeIdsItems = r#AnyOfCompoundTypeNodeIdsItemsString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#AnyOfCompoundTypeNodeIdsItemsString(String);
impl r#AnyOfCompoundTypeNodeIdsItemsString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("AnyOfCompoundTypeNodeIdsItemsString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#AnyOfCompoundTypeNodeIdsItemsString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#AnyOfCompoundTypeNodeIdsItemsString> for String {
    fn from(value: r#AnyOfCompoundTypeNodeIdsItemsString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#AnyOfCompoundTypeNodeIdsItemsString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#AnyOfCompoundTypeNodeIdsItemsString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#AnyOfCompoundTypeNodeIdsItemsString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#AnyOfCompoundTypeNodeIdsItemsString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#CompoundUnion = r#CompoundUnionOneOf;
#[derive(serde :: Serialize, serde :: Deserialize, Clone, Debug, PartialEq, Eq)]
#[serde(untagged)]
pub enum r#CompoundUnionOneOf {
    r#CompoundUnionOneOf0(r#CompoundUnionOneOf0),
    r#CompoundUnionOneOf1(r#CompoundUnionOneOf1),
    r#CompoundUnionOneOf2(r#CompoundUnionOneOf2),
}
impl TryFrom<r#CompoundUnionOneOf> for r#CompoundUnionOneOf0 {
    type Error = ();
    fn try_from(value: r#CompoundUnionOneOf) -> Result<Self, Self::Error> {
        match value {
            r#CompoundUnionOneOf::r#CompoundUnionOneOf0(value) => Ok(value),
            _ => Err(()),
        }
    }
}
impl TryFrom<r#CompoundUnionOneOf> for r#CompoundUnionOneOf1 {
    type Error = ();
    fn try_from(value: r#CompoundUnionOneOf) -> Result<Self, Self::Error> {
        match value {
            r#CompoundUnionOneOf::r#CompoundUnionOneOf1(value) => Ok(value),
            _ => Err(()),
        }
    }
}
impl TryFrom<r#CompoundUnionOneOf> for r#CompoundUnionOneOf2 {
    type Error = ();
    fn try_from(value: r#CompoundUnionOneOf) -> Result<Self, Self::Error> {
        match value {
            r#CompoundUnionOneOf::r#CompoundUnionOneOf2(value) => Ok(value),
            _ => Err(()),
        }
    }
}
pub type r#OneOf9 = r#RecordType;
pub type r#OneOf7 = r#ArrayType;
pub type r#CompoundUnionOneOf1 = r#AnyOfCompound;
pub type r#CompoundUnionOneOf0 = r#OneOfCompound;
pub type r#AnyType = r#AnyTypeInterface;
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
pub struct r#AnyTypeInterface {
    #[serde(rename = "type")]
    pub r#type: r#AnyTypeType,
}
pub type r#StringTypeOptions = r#StringTypeOptionsArray;
pub type r#StringTypeOptionsArray = Vec<r#StringTypeOptionsItems>;
pub type r#BooleanTypeOptions = r#BooleanTypeOptionsArray;
pub type r#BooleanTypeOptionsArray = Vec<r#BooleanTypeOptionsItems>;
pub type r#OneOfCompoundType = r#OneOfCompoundTypeString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#OneOfCompoundTypeString(String);
impl r#OneOfCompoundTypeString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("OneOfCompoundTypeString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#OneOfCompoundTypeString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#OneOfCompoundTypeString> for String {
    fn from(value: r#OneOfCompoundTypeString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#OneOfCompoundTypeString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#OneOfCompoundTypeString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#OneOfCompoundTypeString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#OneOfCompoundTypeString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#OneOf8 = r#InterfaceType;
pub type r#InterfaceTypeType = r#InterfaceTypeTypeString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#InterfaceTypeTypeString(String);
impl r#InterfaceTypeTypeString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("InterfaceTypeTypeString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#InterfaceTypeTypeString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#InterfaceTypeTypeString> for String {
    fn from(value: r#InterfaceTypeTypeString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#InterfaceTypeTypeString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#InterfaceTypeTypeString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#InterfaceTypeTypeString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#InterfaceTypeTypeString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#AnyOfCompound = r#AnyOfCompoundInterface;
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
pub struct r#AnyOfCompoundInterface {
    #[serde(rename = "type")]
    pub r#type: r#AnyOfCompoundType,
    #[serde(rename = "typeNodeIds")]
    pub r#type_node_ids: Option<r#AnyOfCompoundTypeNodeIds>,
}
pub type r#PropertyTypeNodeId = r#PropertyTypeNodeIdString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#PropertyTypeNodeIdString(String);
impl r#PropertyTypeNodeIdString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("PropertyTypeNodeIdString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#PropertyTypeNodeIdString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#PropertyTypeNodeIdString> for String {
    fn from(value: r#PropertyTypeNodeIdString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#PropertyTypeNodeIdString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#PropertyTypeNodeIdString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#PropertyTypeNodeIdString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#PropertyTypeNodeIdString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#TypesItems = r#TypeUnion;
pub type r#ItemTypeNodeIdsItems = r#ItemTypeNodeIdsItemsString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#ItemTypeNodeIdsItemsString(String);
impl r#ItemTypeNodeIdsItemsString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("ItemTypeNodeIdsItemsString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#ItemTypeNodeIdsItemsString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#ItemTypeNodeIdsItemsString> for String {
    fn from(value: r#ItemTypeNodeIdsItemsString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#ItemTypeNodeIdsItemsString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#ItemTypeNodeIdsItemsString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#ItemTypeNodeIdsItemsString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#ItemTypeNodeIdsItemsString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#MinimumLength = r#MinimumLengthNumber;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, Copy, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "usize")]
pub struct r#MinimumLengthNumber(usize);
impl r#MinimumLengthNumber {
    fn new(value: usize) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("MinimumLengthNumber"))
        }
    }
    pub fn validate(&self) -> bool {
        if self.0 == 0 {
            return false;
        }
        true
    }
}
impl TryFrom<usize> for r#MinimumLengthNumber {
    type Error = ValidationError;
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#MinimumLengthNumber> for usize {
    fn from(value: r#MinimumLengthNumber) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#MinimumLengthNumber {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let value = s
            .parse()
            .map_err(|_error| ValidationError::new("MinimumLengthNumber"))?;
        Self::new(value)
    }
}
impl ToString for r#MinimumLengthNumber {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<usize> for r#MinimumLengthNumber {
    fn as_ref(&self) -> &usize {
        &self.0
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#MinimumLengthNumber {
    type Target = usize;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type r#TypeUnionOneOf1 = r#AnyType;
pub type r#Examples = r#ExamplesArray;
pub type r#ExamplesArray = Vec<r#ExamplesItems>;
pub type r#NumberTypeOptionsItems = r#NumberTypeOptionsItemsNumber;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, Copy, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "usize")]
pub struct r#NumberTypeOptionsItemsNumber(usize);
impl r#NumberTypeOptionsItemsNumber {
    fn new(value: usize) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("NumberTypeOptionsItemsNumber"))
        }
    }
    pub fn validate(&self) -> bool {
        if self.0 == 0 {
            return false;
        }
        true
    }
}
impl TryFrom<usize> for r#NumberTypeOptionsItemsNumber {
    type Error = ValidationError;
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#NumberTypeOptionsItemsNumber> for usize {
    fn from(value: r#NumberTypeOptionsItemsNumber) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#NumberTypeOptionsItemsNumber {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let value = s
            .parse()
            .map_err(|_error| ValidationError::new("NumberTypeOptionsItemsNumber"))?;
        Self::new(value)
    }
}
impl ToString for r#NumberTypeOptionsItemsNumber {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<usize> for r#NumberTypeOptionsItemsNumber {
    fn as_ref(&self) -> &usize {
        &self.0
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#NumberTypeOptionsItemsNumber {
    type Target = usize;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type r#Compounds = r#CompoundsArray;
pub type r#CompoundsArray = Vec<r#CompoundsItems>;
pub type r#MinimumProperties = r#MinimumPropertiesNumber;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, Copy, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "usize")]
pub struct r#MinimumPropertiesNumber(usize);
impl r#MinimumPropertiesNumber {
    fn new(value: usize) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("MinimumPropertiesNumber"))
        }
    }
    pub fn validate(&self) -> bool {
        if self.0 == 0 {
            return false;
        }
        true
    }
}
impl TryFrom<usize> for r#MinimumPropertiesNumber {
    type Error = ValidationError;
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#MinimumPropertiesNumber> for usize {
    fn from(value: r#MinimumPropertiesNumber) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#MinimumPropertiesNumber {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let value = s
            .parse()
            .map_err(|_error| ValidationError::new("MinimumPropertiesNumber"))?;
        Self::new(value)
    }
}
impl ToString for r#MinimumPropertiesNumber {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<usize> for r#MinimumPropertiesNumber {
    fn as_ref(&self) -> &usize {
        &self.0
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#MinimumPropertiesNumber {
    type Target = usize;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type r#OneOf6 = r#TupleType;
pub type r#ItemTypeNodeId = r#ItemTypeNodeIdString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#ItemTypeNodeIdString(String);
impl r#ItemTypeNodeIdString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("ItemTypeNodeIdString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#ItemTypeNodeIdString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#ItemTypeNodeIdString> for String {
    fn from(value: r#ItemTypeNodeIdString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#ItemTypeNodeIdString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#ItemTypeNodeIdString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#ItemTypeNodeIdString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#ItemTypeNodeIdString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#MultipleOf = r#MultipleOfNumber;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, Copy, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "usize")]
pub struct r#MultipleOfNumber(usize);
impl r#MultipleOfNumber {
    fn new(value: usize) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("MultipleOfNumber"))
        }
    }
    pub fn validate(&self) -> bool {
        if self.0 == 0 {
            return false;
        }
        true
    }
}
impl TryFrom<usize> for r#MultipleOfNumber {
    type Error = ValidationError;
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#MultipleOfNumber> for usize {
    fn from(value: r#MultipleOfNumber) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#MultipleOfNumber {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let value = s
            .parse()
            .map_err(|_error| ValidationError::new("MultipleOfNumber"))?;
        Self::new(value)
    }
}
impl ToString for r#MultipleOfNumber {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<usize> for r#MultipleOfNumber {
    fn as_ref(&self) -> &usize {
        &self.0
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#MultipleOfNumber {
    type Target = usize;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type r#StringTypeOptionsItems = r#StringTypeOptionsItemsString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#StringTypeOptionsItemsString(String);
impl r#StringTypeOptionsItemsString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("StringTypeOptionsItemsString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#StringTypeOptionsItemsString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#StringTypeOptionsItemsString> for String {
    fn from(value: r#StringTypeOptionsItemsString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#StringTypeOptionsItemsString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#StringTypeOptionsItemsString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#StringTypeOptionsItemsString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#StringTypeOptionsItemsString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#NeverTypeType = r#NeverTypeTypeString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#NeverTypeTypeString(String);
impl r#NeverTypeTypeString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("NeverTypeTypeString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#NeverTypeTypeString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#NeverTypeTypeString> for String {
    fn from(value: r#NeverTypeTypeString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#NeverTypeTypeString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#NeverTypeTypeString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#NeverTypeTypeString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#NeverTypeTypeString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#InterfaceTypeRequiredProperties = r#InterfaceTypeRequiredPropertiesArray;
pub type r#InterfaceTypeRequiredPropertiesArray = Vec<r#InterfaceTypeRequiredPropertiesItems>;
pub type r#PropertyTypeNodeIdsAdditionalProperties =
    r#PropertyTypeNodeIdsAdditionalPropertiesString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#PropertyTypeNodeIdsAdditionalPropertiesString(String);
impl r#PropertyTypeNodeIdsAdditionalPropertiesString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new(
                "PropertyTypeNodeIdsAdditionalPropertiesString",
            ))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#PropertyTypeNodeIdsAdditionalPropertiesString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#PropertyTypeNodeIdsAdditionalPropertiesString> for String {
    fn from(value: r#PropertyTypeNodeIdsAdditionalPropertiesString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#PropertyTypeNodeIdsAdditionalPropertiesString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#PropertyTypeNodeIdsAdditionalPropertiesString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#PropertyTypeNodeIdsAdditionalPropertiesString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#PropertyTypeNodeIdsAdditionalPropertiesString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#TypeUnionOneOf2 = r#NeverType;
pub type r#AllOfCompoundTypeNodeIds = r#AllOfCompoundTypeNodeIdsArray;
pub type r#AllOfCompoundTypeNodeIdsArray = Vec<r#AllOfCompoundTypeNodeIdsItems>;
pub type r#RecordTypeRequiredProperties = r#RecordTypeRequiredPropertiesArray;
pub type r#RecordTypeRequiredPropertiesArray = Vec<r#RecordTypeRequiredPropertiesItems>;
pub type r#AllOfCompoundTypeNodeIdsItems = r#AllOfCompoundTypeNodeIdsItemsString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#AllOfCompoundTypeNodeIdsItemsString(String);
impl r#AllOfCompoundTypeNodeIdsItemsString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("AllOfCompoundTypeNodeIdsItemsString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#AllOfCompoundTypeNodeIdsItemsString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#AllOfCompoundTypeNodeIdsItemsString> for String {
    fn from(value: r#AllOfCompoundTypeNodeIdsItemsString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#AllOfCompoundTypeNodeIdsItemsString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#AllOfCompoundTypeNodeIdsItemsString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#AllOfCompoundTypeNodeIdsItemsString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#AllOfCompoundTypeNodeIdsItemsString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#CompoundsItems = r#CompoundUnion;
pub type r#ArrayTypeType = r#ArrayTypeTypeString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#ArrayTypeTypeString(String);
impl r#ArrayTypeTypeString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("ArrayTypeTypeString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#ArrayTypeTypeString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#ArrayTypeTypeString> for String {
    fn from(value: r#ArrayTypeTypeString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#ArrayTypeTypeString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#ArrayTypeTypeString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#ArrayTypeTypeString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#ArrayTypeTypeString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#BooleanType = r#BooleanTypeInterface;
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
pub struct r#BooleanTypeInterface {
    #[serde(rename = "type")]
    pub r#type: r#BooleanTypeType,
    #[serde(rename = "options")]
    pub r#options: Option<r#BooleanTypeOptions>,
}
pub type r#BooleanTypeType = r#BooleanTypeTypeString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#BooleanTypeTypeString(String);
impl r#BooleanTypeTypeString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("BooleanTypeTypeString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#BooleanTypeTypeString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#BooleanTypeTypeString> for String {
    fn from(value: r#BooleanTypeTypeString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#BooleanTypeTypeString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#BooleanTypeTypeString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#BooleanTypeTypeString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#BooleanTypeTypeString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#TypeUnionOneOf0 = r#NullType;
pub type r#SchemaJson = r#SchemaJsonInterface;
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
pub struct r#SchemaJsonInterface {
    #[serde(rename = "$schema")]
    pub r#schema: Option<r#Schema>,
    #[serde(rename = "nodes")]
    pub r#nodes: r#Nodes,
}
pub type r#StringType = r#StringTypeInterface;
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
pub struct r#StringTypeInterface {
    #[serde(rename = "minimumLength")]
    pub r#minimum_length: Option<r#MinimumLength>,
    #[serde(rename = "options")]
    pub r#options: Option<r#StringTypeOptions>,
    #[serde(rename = "type")]
    pub r#type: r#StringTypeType,
    #[serde(rename = "maximumLength")]
    pub r#maximum_length: Option<r#MaximumLength>,
    #[serde(rename = "valuePattern")]
    pub r#value_pattern: Option<r#ValuePattern>,
}
pub type r#NodesAdditionalProperties = r#Node;
pub type r#InterfaceType = r#InterfaceTypeInterface;
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
pub struct r#InterfaceTypeInterface {
    #[serde(rename = "requiredProperties")]
    pub r#required_properties: Option<r#InterfaceTypeRequiredProperties>,
    #[serde(rename = "type")]
    pub r#type: r#InterfaceTypeType,
    #[serde(rename = "propertyTypeNodeIds")]
    pub r#property_type_node_ids: Option<r#PropertyTypeNodeIds>,
}
pub type r#Schema = r#SchemaString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#SchemaString(String);
impl r#SchemaString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("SchemaString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#SchemaString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#SchemaString> for String {
    fn from(value: r#SchemaString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#SchemaString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#SchemaString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#SchemaString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#SchemaString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#AllOfCompoundType = r#AllOfCompoundTypeString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#AllOfCompoundTypeString(String);
impl r#AllOfCompoundTypeString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("AllOfCompoundTypeString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#AllOfCompoundTypeString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#AllOfCompoundTypeString> for String {
    fn from(value: r#AllOfCompoundTypeString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#AllOfCompoundTypeString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#AllOfCompoundTypeString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#AllOfCompoundTypeString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#AllOfCompoundTypeString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#InterfaceTypeRequiredPropertiesItems = r#InterfaceTypeRequiredPropertiesItemsString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#InterfaceTypeRequiredPropertiesItemsString(String);
impl r#InterfaceTypeRequiredPropertiesItemsString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new(
                "InterfaceTypeRequiredPropertiesItemsString",
            ))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#InterfaceTypeRequiredPropertiesItemsString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#InterfaceTypeRequiredPropertiesItemsString> for String {
    fn from(value: r#InterfaceTypeRequiredPropertiesItemsString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#InterfaceTypeRequiredPropertiesItemsString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#InterfaceTypeRequiredPropertiesItemsString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#InterfaceTypeRequiredPropertiesItemsString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#InterfaceTypeRequiredPropertiesItemsString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#Node = r#NodeInterface;
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
pub struct r#NodeInterface {
    #[serde(rename = "title")]
    pub r#title: r#Title,
    #[serde(rename = "compounds")]
    pub r#compounds: r#Compounds,
    #[serde(rename = "description")]
    pub r#description: r#Description,
    #[serde(rename = "superNodeId")]
    pub r#super_node_id: Option<r#SuperNodeId>,
    #[serde(rename = "deprecated")]
    pub r#deprecated: r#Deprecated,
    #[serde(rename = "types")]
    pub r#types: r#Types,
    #[serde(rename = "examples")]
    pub r#examples: r#Examples,
}
pub type r#NumberTypeOptions = r#NumberTypeOptionsArray;
pub type r#NumberTypeOptionsArray = Vec<r#NumberTypeOptionsItems>;
pub type r#TupleTypeType = r#TupleTypeTypeString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#TupleTypeTypeString(String);
impl r#TupleTypeTypeString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("TupleTypeTypeString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#TupleTypeTypeString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#TupleTypeTypeString> for String {
    fn from(value: r#TupleTypeTypeString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#TupleTypeTypeString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#TupleTypeTypeString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#TupleTypeTypeString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#TupleTypeTypeString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
pub type r#OneOf5 = r#StringType;
pub type r#RecordTypeRequiredPropertiesItems = r#RecordTypeRequiredPropertiesItemsString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#RecordTypeRequiredPropertiesItemsString(String);
impl r#RecordTypeRequiredPropertiesItemsString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new(
                "RecordTypeRequiredPropertiesItemsString",
            ))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#RecordTypeRequiredPropertiesItemsString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#RecordTypeRequiredPropertiesItemsString> for String {
    fn from(value: r#RecordTypeRequiredPropertiesItemsString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#RecordTypeRequiredPropertiesItemsString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#RecordTypeRequiredPropertiesItemsString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#RecordTypeRequiredPropertiesItemsString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
#[cfg(feature = "deref")]
impl std::ops::Deref for r#RecordTypeRequiredPropertiesItemsString {
    type Target = str;
    fn deref(&self) -> &Self::Target {
        self.0.as_str()
    }
}
