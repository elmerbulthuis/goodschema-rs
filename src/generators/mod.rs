mod cargo_toml;
mod file;
mod lib_rs;
mod package;
mod types_rs;

pub use package::PackageGenerator;

// @generated by
//     __             _____     _                 ___ ___
//  _ |  |___ ___ ___|   __|___| |_ ___ _____  __| | |_  |
// | |_| |_ -| . |   |__   |  _|   | -_|     ||. |_  |  _|
// |_____|___|___|_|_|_____|___|_|_|___|_|_|_|___| |_|___|
//                                 -- www.JsonSchema42.org

#[derive(Debug)]
pub struct ValidationError {
    r#type: &'static str,
}
impl ValidationError {
    pub fn new(r#type: &'static str) -> Self {
        Self { r#type }
    }
}
impl std::fmt::Display for ValidationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "validation error for type {}", self.r#type)
    }
}
pub type r#AnyOf0 = r#AnyOf0Interface;
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
pub struct r#AnyOf0InterfaceInterior {
    #[serde(rename = "a")]
    pub r#a: r#A,
    #[serde(rename = "b")]
    pub r#b: r#B,
}
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
#[serde(try_from = "AnyOf0InterfaceInterior")]
pub struct r#AnyOf0Interface(r#AnyOf0InterfaceInterior);
impl r#AnyOf0Interface {
    fn new(value: r#AnyOf0InterfaceInterior) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("AnyOf0Interface"))
        }
    }
    pub fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<r#AnyOf0InterfaceInterior> for r#AnyOf0Interface {
    type Error = ValidationError;
    fn try_from(value: r#AnyOf0InterfaceInterior) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#AnyOf0Interface> for r#AnyOf0InterfaceInterior {
    fn from(value: r#AnyOf0Interface) -> Self {
        value.0
    }
}
impl AsRef<r#AnyOf0InterfaceInterior> for r#AnyOf0Interface {
    fn as_ref(&self) -> &r#AnyOf0InterfaceInterior {
        &self.0
    }
}
impl std::ops::Deref for r#AnyOf0Interface {
    type Target = r#AnyOf0InterfaceInterior;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type r#C = r#CString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, Hash, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#CString(String);
impl r#CString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("CString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#CString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#CString> for String {
    fn from(value: r#CString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#CString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#CString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#CString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
pub type r#A = r#AString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, Hash, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#AString(String);
impl r#AString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("AString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#AString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#AString> for String {
    fn from(value: r#AString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#AString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#AString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#AString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
pub type r#AnyOfObjectJson = r#AnyOfObjectJsonAnyOf;
#[derive(serde :: Serialize, serde :: Deserialize, Clone, Debug, PartialEq, Eq)]
pub struct r#AnyOfObjectJsonAnyOf {
    #[serde(flatten)]
    r#any_of_0: Option<r#AnyOf0>,
    #[serde(flatten)]
    r#any_of_1: Option<r#AnyOf1>,
}
impl TryFrom<r#AnyOfObjectJsonAnyOf> for r#AnyOf0 {
    type Error = ();
    fn try_from(value: r#AnyOfObjectJsonAnyOf) -> Result<Self, Self::Error> {
        value.r#any_of_0.ok_or(())
    }
}
impl TryFrom<r#AnyOfObjectJsonAnyOf> for r#AnyOf1 {
    type Error = ();
    fn try_from(value: r#AnyOfObjectJsonAnyOf) -> Result<Self, Self::Error> {
        value.r#any_of_1.ok_or(())
    }
}
impl AsRef<Option<r#AnyOf0>> for r#AnyOfObjectJsonAnyOf {
    fn as_ref(&self) -> &Option<r#AnyOf0> {
        &self.r#any_of_0
    }
}
impl AsRef<Option<r#AnyOf1>> for r#AnyOfObjectJsonAnyOf {
    fn as_ref(&self) -> &Option<r#AnyOf1> {
        &self.r#any_of_1
    }
}
pub type r#AnyOf1 = r#AnyOf1Interface;
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
pub struct r#AnyOf1InterfaceInterior {
    #[serde(rename = "d")]
    pub r#d: r#D,
    #[serde(rename = "c")]
    pub r#c: r#C,
}
#[derive(Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq)]
#[serde(try_from = "AnyOf1InterfaceInterior")]
pub struct r#AnyOf1Interface(r#AnyOf1InterfaceInterior);
impl r#AnyOf1Interface {
    fn new(value: r#AnyOf1InterfaceInterior) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("AnyOf1Interface"))
        }
    }
    pub fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<r#AnyOf1InterfaceInterior> for r#AnyOf1Interface {
    type Error = ValidationError;
    fn try_from(value: r#AnyOf1InterfaceInterior) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#AnyOf1Interface> for r#AnyOf1InterfaceInterior {
    fn from(value: r#AnyOf1Interface) -> Self {
        value.0
    }
}
impl AsRef<r#AnyOf1InterfaceInterior> for r#AnyOf1Interface {
    fn as_ref(&self) -> &r#AnyOf1InterfaceInterior {
        &self.0
    }
}
impl std::ops::Deref for r#AnyOf1Interface {
    type Target = r#AnyOf1InterfaceInterior;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
pub type r#D = r#DString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, Hash, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#DString(String);
impl r#DString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("DString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#DString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#DString> for String {
    fn from(value: r#DString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#DString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#DString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#DString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
pub type r#B = r#BString;
#[derive(
    Debug, serde :: Serialize, serde :: Deserialize, Clone, PartialEq, Eq, Hash, PartialOrd, Ord,
)]
#[serde(try_from = "String")]
pub struct r#BString(String);
impl r#BString {
    fn new(value: String) -> Result<Self, ValidationError> {
        let instance = Self(value);
        if instance.validate() {
            Ok(instance)
        } else {
            Err(ValidationError::new("BString"))
        }
    }
    fn validate(&self) -> bool {
        true
    }
}
impl TryFrom<String> for r#BString {
    type Error = ValidationError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::new(value)
    }
}
impl From<r#BString> for String {
    fn from(value: r#BString) -> Self {
        value.0
    }
}
impl std::str::FromStr for r#BString {
    type Err = ValidationError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s.to_string())
    }
}
impl ToString for r#BString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
impl AsRef<str> for r#BString {
    fn as_ref(&self) -> &str {
        self.0.as_str()
    }
}
